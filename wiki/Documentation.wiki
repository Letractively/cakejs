#summary Documentation portal for CAKE.

= Introduction =

I'll be pasting and linking the API documentation from cake.js here. And probably writing some sort of introductory tutorial.


== Klass ==

  Klass is used to do inheritance in a less cumbersome fashion than unaugmented JavaScript. To create a new class, you use `MyClass = Klass(superclass, class_body)`. 

  How Klass does inheritance is by going through the parameters to Klass and merging their prototypes or the parameters themselves with the new constructor function's prototype. Finally, the constructor function's prototype is merged with the constructor
  function itself, so that you can write `Shape.getArea.call(this)` instead of
  `Shape.prototype.getArea.call(this)`.

  The constructor function calls the classes `#initialize` with the constructor's arguments, so you can easily derive a class from another and customize its initialization procedure, as you can see from the example below.

{{{
  Shape = Klass({
    getArea : function() {
      raise('No area defined!')
    }
  })

  Rectangle = Klass(Shape, {
    initialize : function(x, y) {
      this.x = x
      this.y = y
    },

    getArea : function() {
      return this.x * this.y
    }
  })

  Square = Klass(Rectangle, {
    initialize : function(s) {
      Rectangle.initialize.call(this, s, s)
    }
  })

  new Square(5).getArea()
  //=> 25
}}}


== CanvasNode == 

  CanvasNode is the base CAKE scenegraph node. All the other scenegraph nodes
  derive from it. A plain CanvasNode does no drawing, but it can be used for
  grouping other nodes and setting up the group's drawing state.

{{{
  var scene = new CanvasNode({x: 10, y: 10})
}}}

  The usual way to use CanvasNodes is to append them to a Canvas object:

{{{
    var scene = new CanvasNode()
    scene.append(new Rectangle(40, 40, {fill: true}))
    var elem = E.canvas(400, 400)
    var canvas = new Canvas(elem)
    canvas.append(scene)
}}}

  You can also use CanvasNodes to draw directly to an augmented canvas context:

{{{
    var scene = new CanvasNode()
    scene.append(new Circle(40, {x:200, y:200, stroke: true}))
    var elem = E.canvas(400, 400)
    var ctx = CanvasSupport.getContext(elem)
    scene.handleDraw(ctx)
}}}

  CanvasNode derives from Transformable and Animatable.


== Canvas ==

  Canvas is the canvas manager class. It takes a canvas element and handles updating its childNodes and drawing them onto the canvas.

  The normal way to use CAKE is to create a Canvas for a canvas element and attaching the scene to the Canvas object. 

  You can set the Canvas's background color by setting the `fill` property to a color, Pattern or Gradient. If you want to preserve the previous frame image, set the `clear` property to false. As an example, preserving the previous frame can be used for doing a motion trail effect by using a transparent background so that it shows the previous frames beneath the current one.

  An example with a rotating rectangle:
{{{
    var c = E.canvas(500, 500)
    var canvas = new Canvas(c)
    canvas.fill = [255,255,255,0.8]
    canvas.clear = false
    var rect = new Rectangle(100, 100)
    rect.x = 250
    rect.y = 250
    rect.fill = 'green'
    rect.addFrameListener(function(t) {
      this.rotation = ((t / 3000) % 1) * Math.PI * 2
    })
    canvas.append(rect)
    document.body.appendChild(c)
}}}

  To use a Canvas as a manually updated image you can set `redrawOnlyWhenChanged` to true. When you want the Canvas to be redrawn, set its `changed` property to true:
{{{
    var canvas = new Canvas(E.canvas(200,40), {
      isPlaying : false,
      redrawOnlyWhenChanged : true
    })
    var c = new Circle(20)
    c.x = 100
    c.y = 20
    c.fill = 'red'
    c.addFrameListener(function(t) {
      if (this.root.absoluteMouseX != null) {
        this.x = this.root.mouseX // relative to canvas surface
        this.root.changed = true
      }
    })
    canvas.append(c)
}}}

  You can also use `onFrame`-calls to make the Canvas redraw itself:
{{{
    var canvas = new Canvas(E.canvas(200,40), {
      isPlaying : false,
      fill : 'white'
    })
    var c = new Circle(20)
    c.x = 100
    c.y = 20
    c.fill = 'red'
    canvas.append(c)
    canvas.onFrame()
}}}

  Using `onFrame` is also the recommended way to use a Canvas inside another Canvas:
{{{
    var canvas = new Canvas(E.canvas(200,40), {
      isPlaying : false
    })
    var c = new Circle(20, {
      x: 100, y: 20,
      fill: 'red'
    })
    canvas.append(c)

    var topCanvas = new Canvas(E.canvas(500, 500))
    var canvasImage = new ImageNode(canvas.canvas, {x: 250, y: 250})
    topCanvas.append(canvasImage)
    canvasImage.addFrameListener(function(t) {
      this.rotation = (t / 3000 % 1) * Math.PI * 2
      canvas.onFrame(t)
    })
}}}


== Other pre-defined canvas node types ==

  * AudioNode is a CanvasNode used to play a sound.
  * ElementNode is a CanvasNode that wraps an HTML element.
  * Line is a line drawn from x1,y1 to x2,y2. Lines are stroked by default.
  * Circle is used for creating circular paths.
  * Ellipse is used for drawing ellipses. 
  * Spiral draws a strokeable spiral path.
  * Rectangle is used for creating rectangular paths.
  * Polygon is used for creating paths consisting of straight line segments.
  * CatmullRomSpline draws a Catmull-Rom spline, with optional looping and path closing. Handy for motion paths.
  * Path is used for creating custom paths. The Path segments are used as `[methodName, arguments]`-calls on the canvas drawing context.
  * ImageNode is used for drawing images.
  * TextNode is used for drawing text on a canvas.


== Fills and strokes == 

  * A value of `null` uses the inherited setting. `false` and `'none'` turn off the fill or stroke.
  * Colors can be given as a CSS color string or an array of color components.
  * Gradient is a linear or radial color gradient that can be used as a stroke or fill.
  * Pattern is a possibly repeating image that can be used as a stroke or
  fill.

  Examples of possible fill / stroke settings.
{{{
  null // use the previous
  true      // use the previous but do fill / stroke
  false     // use the previous but don't do fill / stroke
  'none'    // use the previous but don't do fill / stroke

  'white'   // CSS color name
  '#fff'    // short CSS hex color
  '#ffffff' // long CSS hex color
  'rgba(255,255,255, 1.0)' // CSS RGBA color. RGB and HSLA colors work too, if your browser supports them.
  [255, 255, 255, 1.0] // color component array 
  new Gradient(...)    // gradient fill / stroke
  new Pattern(myImage, 'no-repeat') // pattern fill / stroke
}}}


== SVGParser ==

  SVGParser is an SVG parser for simple documents. Converts SVG DOM to CAKE scenegraph.
  SVGParser has an emphasis on importing graphical images, not on the "HTML-killer" features of SVG.
{{{
  var svgNode = SVGParser.parse(
    svgRootElement, filename, containerWidth, containerHeight, fontSize
  )
}}}
  Features:
    * <svg> width and height, viewBox clipping.
    * Clipping (objectBoundingBox clipping too)
    * Paths, rectangles, ellipses, circles, lines, polylines and polygons
    * Simple untransformed text using HTML
    * Nested transforms
    * Transform lists (transform="rotate(30) translate(2,2) scale(4)")
    * Gradient and pattern transforms
    * Strokes with miter, joins and caps
    * Flat fills and gradient fills, ditto for strokes
    * Parsing simple stylesheets (tag, class or id)
    * Images
    * Non-pixel units (cm, mm, in, pt, pc, em, ex, %)
    * <use>-tags
    * preserveAspectRatio
    * Dynamic gradient sizes (objectBoundingBox, etc.)
    * Markers (though buggy)

  Some of the several missing features:
    * Masks
    * Patterns
    * viewBox clipping for elements other than <marker> and <svg>
    * Text styling
    * tspan, tref, textPath, many things text
    * Fancy style rules (tag .class + #foo > bob#alice { ... })
    * Filters
    * Animation
    * Dashed strokes

